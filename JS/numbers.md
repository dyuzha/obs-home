---
id: numbers
aliases:
  - numbers
tags: []
---
**Back**
    [[!JS]]

# numbers
---
Числа

## Способы записи числа
---
```js
let billion = 1000000000;

let billion = 1000_000_000;

let billion = 1e9;

let mcs = 0.000001;
let mcs = 1e-6; // шесть нулей слева от 1
```

### Системы счисления
---
`0<буква>` - обозначает, что используется другая система счисления (отличная от *base*)
```js
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
```

#### Шестнадцатиричная
---
`0x`
```js
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
```
#### Двоичная
----
`0b`
```js
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
```

#### Восьмиричная
---
`0o`
```js
let b = 0o377; // восьмеричная форма записи числа 255
```
#### toString(base)
---
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

## Сравнение `Object.is` (Aналог isinstance() в Py)
---
Существует специальный метод `Object.is`, который сравнивает значения примерно как `===`, но более надёжен в двух особых ситуациях:

1. Работает с `NaN`:
```js
Object.is(NaN, NaN) === true // здесь он хорош.
```
2. Значения `0` и `-0` разные:
```js
Object.is(0, -0) === false // это редко используется, но технически эти значения разные.
```
Во всех других случаях `Object.is(a, b)` идентичен `a === b`.

Этот способ сравнения часто используется в спецификации JavaScript.
Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует `Object.is`.

## parseInt, parseFloat
---
Читают число из строки
Возвращаеют NaN в случае ненахода...
```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```
