**Back**
[[Python]]


# Конструирование и инициализация
---

## New
---
>[!Note] Sample
`__new__(cls, [...])`
- Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, который переданы в  `__init__`

*P.S. Хорошо описан в документации*


## Init
---
>[!Note] Sample
```python
__init__(self, [...])
```
- Инициализатор класса. Ему передается все, с чем был вызван первоначальный конструктор. 

>[!Example]
```python
class FileObject:
    def __init__(self, filepath='puth/to/file', filename='sample.txt'):
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
    self.file.close()
    del self.file
```


## Del
---
`__del__(self)`
- Деструктор объекта. 
>[!Info] `__del__` всегда вызывается по завершении работы интерпритатора

# Менеджеры контекста
---
**Менеджеры контекста** позволяют выполнить какие-либо действия для настройки или очистки, когда создание объекта обернуто в оператор with.
- Поведение менеджера контекста определяется двумя магическими методами.

## Enter 
---
`__enter__(self)`
Определяет, что должен сделать менеджер контекста в начале блока, созданного оператором **with**. 
- Возвращаемое `__enter__` значение и есть то значение, с которым производиться работа внутри **with**.



## Exit
---
 `__exit__(self, exception_type, exception_value, traceback)`
 Определяет действия **менеджера контекста** после того, как блок будет выполнен (или прерван во время работы). Может использоваться для контролирования исключений, чистки, любых действий которые должны быть выполнены незамедлительно после блока внутри **with**. Если блок выполнен успешно, `exception_type`, `exception_value` и `trace_back`, будут установлены в **None**.

В другом случае вы сами выбираете, перехватывать ли исключение или предоставить это пользователю.
- Если вы решили перехватить исключение - убедитесь, что `__exit__` возвращает `True`, после того как все сказано и сделано.
- Если вы решили что исключение не будет перехвачено **менеджером**, просто позвольте ему случиться.

# Строковые методы
---
Объект `object`, от которого наследуются все объекты в *Py* имеет строковый метод `__str__()`

## Str
---
`__str__()`
```python
def __str__(self): 
    return <string>
```
P.s. Данный метод лучше оборачивать в другой метод для вывода в консоль (по типу `display_data()`)


# Repr
---
`__Repr__`


# Get
--
`__get__` - определяет поведение при доступе к атрибуту обьекта. 
- Позволяет объектам контролировать доступ к своим атрибутам


# Eq (equal)
---
`__eq__ ` - проверяет на равенство


# Del (delete) - Деструктор
---
`__del__(self)` 
**Деструкторы** вызываются при удалении методов

- В нем указываются действия, которые необходимо выполнить при удалении объекта
    - Н-р: удаление или освобождение ресурсов, которые использовал объект

-Деструктор вызывается автоматически интерпритатором (его явным образом вызывать не требуется)

>[!Example]
```python
class Person:
    def __init__(self, name):
        self.name = name
        print(f"Created Person with name a {self.name}")
    
    def __del__(self):
        print(f"Deleted Person with name a {self.name}")
tom = Person("Tom") # >> Created Person with name a Tom
                    # >> Deleted Person with name a Tom
```
- Программа создает один объект *Person* и хранит ссылку на него в переменной tom
    - Создание объекта вызовет выполнение **конструктора**.
    - Завершение программы вызовет выполнение **деструктора**
