---
id: dockerfile
aliases:
  - Dockerfile
tags: []
---
**Back**
    [[Docker]]

# Dockerfile
---

| Value      | Description                                                                                          |
|------------|------------------------------------------------------------------------------------------------------|
| FROM       | Задает базовый родительский образ                                                                    |
| ENV        | Описывает метаданные (кто создал и поддерживает образ)                                               |
| RUN        | Выполняет команду и создает слой образа                                                              |
| COPY       | Копирует в контейнер файлы и папки                                                                   |
| ADD        | Копирует файлы и папки в контейнер, Может распаковавать лок. .tar файлы                              |
| CMD        | Описывает команду с аргументами, выполняющуся в запущенном контейнере                                |
| WORKDIR    | Задает рабочую директорию для следующей инструкции                                                   |
| ARG        | Задает переменные для передачи Docker во время сборки образа                                         |
| ENTRYPOINT | Предоставляет команду с аргументами (не переопределяемыми) для вызова во время выполнения контейнера |
| EXPOSE     | Указывает на необходимость открыть порт                                                              |
| VOLUME     | Создает точку монтирования для работы с постоянным хранилищем                                        |


## Оптимизация
---
- Многоэтапная сборка - уменьшает размер итогового образа
- Правильный порядок интсрукций - Docke кэширует слои, поэтому редко меняющиеся инструкции должны быть в начале
-  Использование .dockerignore - исключает ненужные файлы из образа

**Начало**
Любой файл начинается с инструкций:
- `FROM`
или
- `ARG`, за которой идет `FROM`


## Примеры dockerfile
---
```dockerfile
# Пример самого простого dockerfile
FROM ubuntu:18.04
```

```dockerfile
# Задает базовы образ для сборки
FROM ubuntu:20.04

# Выполняет команду внутри контейнера во воемя сборки
RUN apt-get update && apt-get install -y python3

# Аналогично COPY, но с дополнительными возможностями
# (распаковка архивов, загрузка по URL)
ADD https://example.com/file.tar.gz /tmp/

# Устанавливает рабочую директорию
WORKDIR /app

# Устанавливает переменные окружения
ENV PYTHONPATH=/app

# Указывает порты, которые будет прослушивать котейнер
EXPOSE 8080

CMD ["python3", "app.py"]

# Аналогично CMD, но с более высоким приоритетом
ENTRYPOINT ["python3"]

# Определяет переменные, передаваемые при сборке
ARG VERSION=latest
```

### ADD
---
Копирует файлы и директории из хоста или из URL образ Docker.
- Сохраняет права доступа к файлам, но владельцем становится root
- Кеширование: Docker кэширует результаты выполнения ADD, пока не изменятся исходные файлы
- Поведение с директориями: Если источник - директория, скопируется все ее содержимое (без самой директории)
- URL-источники: Файлы, загруженные по URL, не распаковываюься автоматически

```dockerfile
ADD <source> <target>
```


#### Варианты использования
---
1. Копирование локальных файлов
```dockerfile
ADD app.py /app/
```

2. Автоматическая распаковка архивов
```dockerfile
# ADD автоматически распаковывает архивы (.tar, .tar.gz, .tar.bz2, .tar.xz, .zip) при копировании
ADD archive.tar.gz /tmp/
# Содержимое архива archive.tar.gz будет распакованно в  /tmp
```

3. Загрузка файлов по URL
```dockerfile
ADD https://example.com/file.txt /tmp/file.txt
```


#### Кеширование
---
 1. Проверка контрольной суммы
 Docker вычисляет хеш (контрольную сумму) для каждого файла/архива/URL, указыванного в ADD
 Если хеш не изменился с последней сборки - используется кэшированный результат

2. Что учитывается
- Для локальных файлов: содержимое файла и его метаданные (размер, время изменения)
- **Для URL (содержимое по URL не проперяется при сборке)**

3. Когдп кеш инвалидируется
- Если изменилось содержимое файла
- Если изменилось имя файла (если используется шаблон, например ADD *.txt /dit/ )
- Если изменились аргументы команды

### RUN
---
Выполнить во время сборки
Выполняется во время сборки образа (`docker build`)
Назначение: Устанавливает пакеты, создает файлы/директории, настраивают окружение
```dockerfile
# Shell форма
RUN apt-get update && apt-get install -y curl

# Exec форма
RUN ["apt-get", "update"]
```
- Каждая инструкция RUN создает слой образа
- Результат выполнения сохраняется в образе
- Не может быть переопределена при запуске контейнера


### CMD
---
Команда по умолчанию
Выполняется при запуске контейнера (`docker run`)
Определяет команду и аргументы по умолчанию
```dockerfile
# Shell форма
CMD command param1 param2

# Exec  форма
CMD ["executable", "param1", "param2"]
```
- Можно переопределить при запуске контейнера
- В Dockerfile может быть только одна инструкция CMD
- Если указан ENTRYPOINT, то CMD становится его аргументами

### ENTRYPOINT
---
Основная команда
Выполняет основную исполняемую команду

```dockerfile
# Shell форма
ENTRYPOINT command param1

# Exec  форма
ENTRYPOINT ["executable", "param1"]
```
- Можно переопределить только через `--entrypoint`
- Аргументы `docker run` добавляются в конец команды
- Хорош лоя создания *исполняемых* контейнеров


## Когда что использовать
---
RUN: Для установки софта и настройки окружения
CMD: Когда нужно задать аргументы по умолчанию, которые могут быть переопределены
ENTRYPOINT: Когда контейнер должен работать как исполняемый файл


### EXPOSE
---
**Документирование** - показвает, какие порты предназначены для работы приложения
**Информирование Docker** - указывает, какие порты могут быть опубликованы

```dockerfile
EXPOSE <port> [<port>/<protocol>]

# Примеры
EXPOSE 80
EXPOSE 80/tcp
EXPOSE 80/udp
EXPOSE 80 443
EXPOSE 3000-3005
```

1. Не открывает порты автоматически
 EXPOSE только объявляет о намерении использовать порт
 Чтобы реально открыть порт, нужно использовать -p при запуске
 `docker run -p 80:80`
2. Протокол по умолчанию
Если протокол не указан, используется TCP

3. Не влияет на безопасность
Без -p порт остается закрытым для внешнего мира
Это просто метаданные образа

```dockerfile
# Базовый пример веб-сервера
FRON nginx
EXPOSE 80

# Для приложения с несколькими портами
FRON myapp
EXPOSE 3000 # соновной порт приложения
EXPOSE 9229 # порт для отладки

# С указанием протоколы
FROM voip-app
EXPOSE 5060/udp # SIP порт
EXPOSE 5060/tcp # SIP over TCP
```


## VOLUME
---
 Создает точку монтирования для внешних томов (volumes) или host-директорийи и помечает ее как содержащую внешне смонтированные данные
 1. Создает точки монтирования - определяет, где контейнер будет хранить/читать данные
 2. Документирование - показывает, какие директории предназначены для хранения данных
 3. Автоматическое создание тома - если том не указан явно при запуске

===
Данные в volume сохраняются после удаления контейнера
При первом запуске, если том пуст, в него копируются данные из образа
При последующих запусках используются существуюшие данные
Один том мб подключен к нескольким контейнерами одновременно
===

### Синтаксис
---
```dockerfile
VOLUME ["/path/to/mount"]
VOLUME /path/to/mount
VOLUME /path1 /path2
```


### Принцип работы
---
1. При сборке образа.
Создается точка монтирования
Все существующие данные в этой директории копируются в новый том

2. При запуске контейнера.
Если том не указан, Docker создает анонимный том (Если не сохранить имя, то будет сложно найти потом)
Если том указан через `-v`, или `--mount`, используется указанный том

### Разница между VOLUME и -v/--mount
---
| VOLUME                 | -v / --mount                        |
|------------------------|-------------------------------------|
| Определяется в образе  | Определяется при запуске            |
| Создает анонимный том  | Может использовать именованные тома |
| Ограниченная настройка | Гибкие настройки монтирования       |
| Часть образа           | Часть runtime конфигурации          |

Вывод: VOLUME в Dockerfile — это "намёк" на то, что здесь должны быть внешние данные, но реальные тома лучше задавать при запуске через -v.
