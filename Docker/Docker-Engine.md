# Docker-engine
---
Open sourse технология контейниризация для создания и контейнеризации приложений
- Построен на клиент серверной архитектуре
В его состав входит:
- **dockerd**  демон стоит на сервере
- API, оперделяющие интефейсы, которые прораммы могут использовать для взаимодействия с **dockerd** и передачи ему инструкций
- CLI client docker
  CLI использует Docker API для контроля и взаимодействия c dockerd через скрипты  или прямые команды
  *(Больщинство сторонних приложений используют API и CLI)*

# Для чего можно использовать Docker?
---
- Оптимизирует жизненный цикл разработки, позволяя разработчикам работать в стандартизированных средах, используя локальные контейнеры.
Контейнеры отлично подходят для рабочих процессов непрерывной интеграциии и непрерывыной поставки **Continuous Integration and Continuos Delivery (CI/CD)

## Возможные сценарии
---
- Разработчики пишут код локально и делятся работой с коллегами с помощи контейнеров Docker
- Размещения своих приложений в тестовой среде и запуска автоматизированных и ручных тестов
- При обнаружении ошибок, исправление и повторное развертование сожет проходить в тестовой среде для тестирования и проверки
- После завершения тестирования предоставить исправление клиенту также просто, как загрузить обновленный образ в производственную среду


# Docker architecture
---
Docker использует клиент-серверную архитектуру.

Docker-client и Docker-daemon - могут работать на одной системе или на разных.

Docker-client взаимодействует с dockerd

Docker-daemon отвечает за:
- создание
- запуск
- распространение
... Docker-контейнеров

Docker-client и Docker-daemon взаимодейыствуют с помощью REST API через сокеты UNIX или сетевой интерфейс.

Docker Compose - еще один docker client, позволяющий работать с приложениями, состоящими из набора контейнеров

# Docker daemon
---
- прослушивает **Docker API** запросы и управляет Docker-объектами, такими как образы, контейнеры, сети и тома
- может также коммуницировать с другими демонами управляемыми Docker сервисами 

# Docker client
---
`docker` - это основной способ взаимодействия многих пользователей c **Docker**
`docker` исопльзует docker-API
`docker run` - клиент отправляет команду *dockerd*, который их выполняет
- Docker-client может взаимодействовать более, чем с одним docker-daemon

# Docker-desktop
---
- Легкое в установке приложение, позволяющие создавать и совместно использовать контейнеризированные приложения и микросервисы
- Включает в себя:
    - Docker daemon (dockerd)
    - Docker client (docker)
    - Docker Content Trust
    - Kubernetes
    - Credential Helper

# Docker registries
---
**Реестр Docker** - хранит образы докер.
**Docker Hub** - публичный регистр  *(Docker по умолчанию ищет образы в Docker Hub)*
Комманды `docker pull`/`docker run` извлекают/помещают требуемые образы из/в настроенный(ого) реестр(а)

# Docker objects
---
При использовании **Docker**, создаютсся и используются образы контейнеры, сети, тома, плагины и другие объекты

## Images
---
Образ - это шаблон *read-only* с инструкциями по созданию контейнера **Docker**
*Часто образы создаются на основе других образов, с добавлением кастомизации*
Для примера, можно создать базовый образ на основе образа `ubuntu`, но с установленным **Apache web server** и еще како-нибудь приложение, а также сведения конфигурации для запуска этого приложения.
Для создания образа, необходимо: 
- Создать DockerFile с простым синтаксимом, где определить все нужные шаги для создания и запуска образа.
- Каждая инструкция в DockerFile создает слой в образе.
- Когда изменяется DockerFile и пересобирается образ, пересобираются только те слои, что подвергались изменениям.
=> Это от части то, что делает образы легкими, маленькими и быстрыми

# Containers
---
**Container** - запускаемый образец образа.
- Можно создать, запустить, остановить, переместить или удалить контейнер, используя Docker API или CLI
- Можно подключить от 1 до нескольких сетей
- Прикрепить к нему хранилище
- Создать новый образ на основе текущего состояния
- Можно контролировать степень изоляции всех подсистем (например, приведенных выше) от других контейнеров
- Контейнер определяется 
    - своим образом
    - любыми параметрами конфигурации, которые предоставляются при создании или при запуске
- При удалении контейнера, любые изменения его состояния исчезают

>[!EXAMPLE]
```bash
docker run -i -t ubuntu bin/bash
```
Изнутри это выглядит так:
1. Если локально ubuntu образа нет, докер скачивает его из настроенного регистра через команду `docker pull ubuntu`
2. Докер создает контейнер, также как `docker pull ubuntu`
3. Docker выделяет файловую систему reed-write для контейнера в качестве последнего слоя.
4. Docker создает сетевой интерфейс для подключения по умолчанию 
    Т.к. не указаны никакие сетевые опции. Это включает назначе
    - По умолчанию контейнеры могут подключаться к внешним сетям, используя сетевое подключение хост-машины.
5. Docker запускает контейнер и выполняет `/bin/bash`. Поскольку контейнер запущен в интерактивном режиме и подключен к вашему терминалу (благодаря флагам `-i`, `-t`)
    Данные можно вводить с клавиатуры, docker записывает вывод на терминал хоста
6. При запуске команды `exit` для завершения команды `/bin/bash`, контейнер остановиться, но не удалиться.
    Дальше его можно запустить или удалить.

# Основополагающая технология 
**Docker** написан на Go и использует ряд возможностей ядра **Linux** для реализации функциональности.
- **Docker** использует технологию называемую "Пространство имен", для предоставления изолированного рабочего пространства, называемого "Контейнером".
- При создании контейнера, **Docker** создает  набор пространства имен для этого контейнера
- Эти пространства имен обеспечивают уровень изоляции. Каждый аспект контейнера выполняется в отдельном пространстве имен, и его доступ ограничен этим пространством имен.
