---
id: http
aliases:
  - http
tags: []
---
**Back**
    [[!Base]]

# http
---
sources: [Habr](https://habr.com/ru/companies/avito/articles/710678/)

## http 1 -> htttp 1.1
---
1999 г

### Новые методы
---
Добавились новые методы: PUT, DELETE, TRACE
Затем добавились дополнительные методы: CONNECT, PATCH

### Кеширование
---
Добавилось кеширование запрашиваемых ресурсов

Возможность располагать несколько сайтов на одном IP
Появился обязательный заголовок: host (содержит домен сервера с которого пришел запрос)

### Keep-alive
---
Позволяет сохранять одно TCP соединение для нескольких запросов
В http 1 требовал дополнительного заголовка с обоих сторон
`Connection: Keep-alive`
`Connection: close` (закрытие TCP-тунеля)
В http 1.1 стал *default*, без необходимости добавлять дополнительные заголовки

### Механизм потоковой передачи
---
При передачи большого объема данных, серверу требуется закачать все данные в оперативку.
В результате образуются 2 проблемы:
1. Данные будут отправлены, только после полной загрузки
-> Ломает концепцию потокового воспроизведения (потоковое видео = неизвестный размер)
2. Запросы к серверу от каждого клиента будут задействовать определенный размер оперативной памяти и быстро израсходуют физические лимиты на сервере

Решение:

Данные передаются **чанками**
Длина чанка зависит от настройки сервера

В ответ на запрос сервер присылает заголовок: `Transfer-Encoding` со значением `chunked`
Когда передача данных заканчивается, последним присылается **chank** нулевой длины.

```sh
HTTP/1.1 200 OK
Transfer-Encoding: chunked # <- заголовок со значением

10 # <- Длина (в байтах) ответа
Long chunk # <- Ответ
19 # <- Длина (в байтах) ответа
One more chunk data # <- Ответ
0 # <- Нулевая длина (данные закончились)
```


## http 1.1 -> http 2
---
2009 г.

### Бинарные данные
---
Использование бинарного формата для передачи данных.
Браузеры с поддержкой HTTP/2 кодируют данные в бинарный формат, а сервер - декодирует

### Мультиплексирование
---
Сайт работает так:
1. Клиент:
    <- GET-запрос
2. Сервер:
    <- HTML-страница, которая в свою очередь подключает дополнительные рес-сы:
      <- js-файлы
      <- css-таблицы
      <- картинки
      <- шрифты и тд.

3. После загрузки всех (или почти всех) ресурсов, сайт становится доступен пользователю

HTTP 1 - устанавливает каждое новое TLS - соединение для каждого ответа, в одном потоке
HTTP 1.1 - осуществляет все ответы в рамках одного TLS-соединения в одном потоке (благодаря **Keep-alive**)
**HEAD-Of-Line-Block** Если один запрос из цепочки подвисает, он блокирует все остальные запросы

Бинарный формат данных позволил загружать несколько ресурсов - одновременно.
1. Вся информация разбивается на фреймы
2. Передается в разных потоках в рамках одного TLS-соединения

### Сжатие заголовков
---
HTTP 1, 1.1 сжатие заголовков происходило на уровне TLS (это более низкий уровень по отношению к HTTP - микс транспортного уровня и уровня приложения)
Он не знает какие данные сжимает, и сжимает все через gzip, алгоритм [[DEFLATE]]
=> Подвержены атакам [[CRIME]]
=> Можно получить авторизованные куки из сжатых заголовков
=> Многие пограничные сети (например, Cloudflare) блокировали сжатие заголовков, чтобы защитить пользователей от атак.

HTTP 2 - новый алгоритм сжатия [[HPACK]] (Он не использует [[DEFLATE]] и заточен под защитц от [[CRIME]] )

### Приоритизация потоков
---
Механизм приоритизации потоков, позволяет управлять порядком обработки и передачи потоков данных на одном соединении.
- Улучшает производительность
- Делает управление ресурсами эффективнее
- Позволяет гибко контролировать рендеринг страницы

При отправке параллельных запросов на сервер, клиент может расставить приоритеты (от 1 до 256)
Потоки мб связаны с ресурсами на сервере (css, js, ...)

### Server push
---
Позволяет начать передачу ресурсов на клиент еще до запроса

1. Клиент GET -> /index.html
2. Сервер анализирует запрос и определяет, какие ресурсы нужны для полной загрузки страницы (css, js, ...)
3. Сервер отправляет /index.html, со всеми зависимостями (css, js, ...)
4. Клиент получает полный набор, не запрашивая его явно
