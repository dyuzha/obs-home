>**More**
>[[py-magic]]


# ООП простыми словами #
---
**Класс** - Чертеж робота.
**Объект** - Робот.
**Наследование** - Добавление опций к роботу (крыльев, двигателя и тд)
**Полиморфизм** - Общий функционал для всех роботов (не важно как реализован, важно ОДНОИМЕННОСТЬ функций).
**Инкапсуляция** - Броня для робота (*private* и *protected*) - робот полностью защищен от внешних вмешательств.

Когда создается объект, первым делом вызывается метод `__new__` *(а не `__init__`)*


# Type
---
- Альтернативный способ создания классов.
`type` - это class для классов, т.е. **метакласс** (фабрика по созданию классов)

>[!Note] Sample
```python
type(<class-nm>,
    <tuple parents classes>,
    <dictionary {attr:value}>
```

## Добавление метода
---
Для добавления метода необходимо определиться функцию с нужной *сигнатурой* и присвоить ее в качестве аттрибута.
>[!Note] Sample
```python
Foo = type('Foo', (), {'bar': True})

def echo_bar(self):
    print self.bar

FooChild = type('FooChild', (Foo), {'echo_bar': echo_bar})

my_foo = FooChild()
my_foo.echo_bar()

>>> True
```


# Метаклассы
---
**Основная цель метаклассов** - автоматически изменять класс в момент создания.
- Обычно это делаетcя для **API**, когда хочется создавать классы в соответствии с текущем контекстом.

>[!Warning] Алгоритм действий *Py*
```python
class Foo(Bar):
    pass
```
Есть ли у класса **Foo** аттрибут `__metaclass__`?
    Да: Создает в памяти объект-класс с именем Foo, используя то, что указано в `__metaclass__`.
    Нет: *Py* ищет `__metaclass__` в:
            - родительском классе (в данном случае *Bar*)
            - на уровне модуля
        Если не нашел ни одного `__metaclass__`, то использует **type** для созданият объекта-класса.


## Пользовательские **метаклассы**
---
`__metaclass__` мб любым вызываемым объектом - не обизательно формальным классом


