---
id: cgroups
aliases: []
tags: []
---
**Back**
    [[!Lin]]

# Cgroups
---
*Контрольная группа* - группа процессов в Linux, для которой механизмами ядра наложена изоляция и установлены ограничения на некоторые вычислителсьные ресурсы (CPU, networking, memory, stotage, i/o)
Механизм позволяет образовывать иерархические группы процессов, и управлять ими

(???) Утилита nice

source: [Wiki - Контрольная группа (Linux)](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B0_(Linux))
Для контейнеризации изоляции пространства имен мало (изоляции ресурсов), если запускать какое-либо приложение, необходимо быть увереныс в том, что
- этому приложению выделено достаточно ресерсов
- и что оно не будет потреблять лишние ресурсы

Для решения этой задачи в ядре Linux имеется специальный механизм - *cgroup*

Файловая система **croupsfs**

## Архитектура
---
Механизм *cgroups* состоит из 2-ух частей:
- Ядро (cgroup core)
- 12 Подсистем:
  - blkio - устанавливает лимиты на чтение и запись с блочных устройств
  - cpuacct - генерирует отчеты об использовании ресурсов процессора
  - cpu - обеспечивает доступ процессов в рамках контрольной группы к CPU
  - cpuset - распределяет задачи в рамках контрольной группы между процессорными ядрами
  - devices - разрешает или блокирует доступ к устройствам
  - freezer — приостанавливает и возобновляет выполнение задач в рамках контрольной группы
  - hugetlb — активирует поддержку больших страниц памяти для контрольных групп;
  - memory — управляет выделением памяти для групп процессов;
  - net_cls — помечает сетевые пакеты специальным тэгом, что позволяет идентифицировать пакеты, порождаемые определённой задачей в рамках контрольной группы;
  - netprio — используется для динамической установки приоритетов по трафику;
  - pids — используется для ограничения количества процессов в рамках контрольной группы.

```bash
# Вывести список подсистем на консоль
ls /sys/fs/cgroup
```

Кадая подсистема представляет собой директорию с управляющими файлами, в которых прописваются все настройки

Структура *cgroup*:
- Ядро
- 12 Подсистем:
  - ...

  - Каждая подсистема содержит сл. управляющие файлы:

    - `cgroup.clone_children` (0/1) - Позовляет передавать дочерним контрольным группам свойства родительских

    - `tasks` - Содержит список **PID** процессов, включенных в контрольные групы

    - `cgroup.procs` - Содержит список TGID групп процессов, включенных в контрольные группы

    - (???) `cgroup.event_control` - Позволяет отправлять уведомления в случае изменения статуса контрольной группы

    - `release_agent` - Содержится команда, которая будет выполнена, если включена опция `notify_on_release`. МБ использовано для автоматического удаления пустых контрольных групп

    - `notify_on_release` (0/1) отключает/включает выполнение команды, указанной в release_agent.

    - *Свои уникальные файлы*

  - ...

## Действия
---
##### Создание контрольной группы
-> создать вложенную директорию в любой из подсистем.
-> В эту вложенную директорию будут автоматически добавлены управляющие файлы

##### Добавление процессов в группу
-> Записать PID процессов в управляющий файл tasks

Совокупность контрольных групп, встроенных в подсистему, называется иерархией.

### Управление процессорными ресурсами
---
```bash
# Создание контрольной группы
mkdir /sys/fs/cgroup/cpuset/group0

# Посмотреть содержимое только что созданной контрольной группы
ls /sys/fs/cgroup/cpuset/group0

# Посмотреть процессы
cat /sys/fs/cgroup/cpuset/group0/tasks # >>> Пусто, так как процессов все еще нет

# Добавление процесса в группу
echo $$ >> /sys/fs/cgroup/cpuset/group0/tasks
# $$  - PID процесса, выполняемого текущего командной оболочкой
```
- Если выскакивает ошибка "Не достаточно памяти", значит нет узлов памяти,  назначенных cpuset (и скорей всего cpu-узлов)
Необходимо выполниить сл. действия:

```bash
# Проверить назначенные узлы памяти
cat /sys/fs/cgroup/cpuset/group0/cpuset.mems
#>>> Вернет пустую строку
# => У нее не будет памяти для работы
# => Ей нельзя назначить задачу

# Назначение одного или всех узлов памяти этой cgroup должно исправить это
echo 0 > /sys/fs/cgroup/cpuset/group0/cpuset.mems

# Назначить cpu-узел (Если он тоже будет пустым)
echo 0 > /sys/fs/cgroup/cpuset/group0/cpuset.cpus
```


#### Посмотреть статус процесса
---
```bash
# Посмотреть статус процесса
cat /proc/$$/status |grep '_allowed'

# Текущему процессу разрешено использовать 3 процессора
Cpus_allowed:   3

# Текушему процессу разрешено использовать процессоры с номерами 0 и 1
Cpus_allowed_list:      0-1

# Разрешено использовать определенную область памяти
Mems_allowed:,00000000,00000001

# В списке разрешенных областей памяти нет элементов
Mems_allowed_list:      0
```

#### Привязать cgroup к процессу с именем 0
---
```bash
echo 0 > /sys/fs/cgroup/cpuset/group0/cpuset.cpus
# Теперь все группы процессов могут использовать только процессор с именем 0
``````

### Управление памятью
---
```bash
# Создать такуюже группу еще в одну подсистему
mkdir /sys/fs/cgroup/memory/group0

# Далее поместим процесс в данную группу
echo $$ > /sys/fs/cgroup/memory/group0/tasks

# Выставление ограничения на потребления памяти
echo 40M > /sys/fs/cgroup/memory/group0/memory.limit_in_bytes

# Ограничение от OOM-киллера
echo 1 > /sys/fs/cgroup/memory/group0/memory.oom_control
cat /sys/fs/cgroup/memory/group0/memory.oom_control
oom_kill_disable 1
under_oom 0
...
```
> [!NOTE] Защита от OOM-Killer
> Если поместить в отдельную контрольную группу, например ssh-демон, и отключить для этой группы OOM-Killer, то мы можем быть уверены в том, что он не будет УБИТ при увеличении потребления памятиb (см. [[OOM-Killer]])

### Управление устройствами
---
```bash
# Создание контрольгнуой группы в очередной иерархии
mkdir /sys/fs/cgroup/devices/group0

# Вывести все устройства
cat /sys/fs/cgroup/devices/group0/devices.list
# a *:* rwm
# По умолчанию у группы нет никаких ограничений доступа к устройствам

# Включить /dev/null  в список запрещенных устройств
echo 'c 1:3 rmw' > /sys/fs/cgroup/devices/group0/devices.deny

# Добавить текущий шел процесс в группу
echo 'c 1:3 rmw' > /sys/fs/cgroup/devices/group0/devices.deny

# Попробовать воспользоваться диском
echo "test" > /dev/null # >>> Operation not permitted

# Восстановить доступ
echo a > /sys/fs/cgroup/devices/group0/devices.allow
```
More [[cgroups-dev-consd]]
