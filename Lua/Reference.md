---
id: Reference
aliases: []
tags: []
---

More:
[[featch]]

# Lua
---
Используется для транспиляции

## Типы данных
---
- nil (Null)
- bool (true/false)
- numbers (Не делятся на float/int)
- функции
- строки (Похоже на строки в паскале)
- thread (Поток)
- userdata (Произвольные данные)
- table (Таблица)

## Таблица
---
Таблица - изящная структура данных, она сочетает в себе
- свойства массива
- хеш-таблицы (ключ - значение)
- структуры объекта

### Определение
---
```lua
-- Пример таблицы как массива:
local a = {1, 2, 3}
print(a[2]) -- 2, так как индексы считаются с еденицы

-- Пример разряженного массива (У которого есть не все элементы)
local b = {} -- пустая таблица
b[1] = 1
b[3] = 5
print(b[2]) -- nil

-- Пример таблицы как словаря
local c = {}
c['hello'] = true
c['word'] = false
c[true] = 1
print(c["hello"]) -- true
print(c."hello") -- true (Тоже самое, что и c["hello"])

-- Другой способ создания словаря
local d = {
  hello = 123,
  world = 456
}

print(d.hello) -- 123
```


### Перебор в цикле
---
Перебор в цикле всех ключей и значений

```lua
local t = {
  a = 3,
  b = 4
}
-- pairs(value) - парсит таблицу на key, value
for key, value in pairs(t) do
  print(key, value)
end
```

## Функции
---

### Определение
---
Функции языка позволяют принимать несколько аргументов, и возвращать несколько аргументов
- Если значение аргументов не указаны явно, считаются `nil`
```lua
local function add(a, b)
  return a + b
end

print(add(5, 3)) --  "8"
```

Если функция возвращает несколько аргументов, их можно игнорировть с помощью `_`
```lua
a, _, _, d = some_function()
```

```lua
-- В прототипе переменное число аргументов записывается как "..."
local function sum(...)
  local s = 0
  -- В функции к таким аргументам обращаются как к таблице arg
  -- Или явно преобразовываются аргументы в таблицу {...}
  for _, n in pairs({...}) do
    s = s + n
  end
  return s
end

print(sum(1, 2, 3)) -- 6
print(sum(1, 2, 3, 4)) -- 10
```

Создание переменных-функций
```lua
local a = function(x) return x * 2 end

local function apply(table, f)
  local result = {}
  for k, v in pairs(table) do
    -- Заменяет элемент на функцию f
    result[k] = f(v)
  end
  return result
end

local t = {1, 3, 5}
local res_t = apply(t, a)

for key, value in pairs(res_t) do
  print(key, value)
end
-- 1       2
-- 2       6
-- 3       10
```

## Объекты
---
- Отсутсвуют классы
- Наследование прототипное

### Определение
```lua
local lamp = {
  on = false,

  turn_on = function(l)
    l.on = true
    print("ON")
  end,

  turn_off = function(l)
    l.on = false
    print("OFF")
  end
}

lamp.turn_on(lamp)
lamp.turn_off(lamp)

-- Алтернатива (Синтаксический сахар)
lamp:turn_on()

-- Еще одна альтернатива
lamp["turn_on"](lamp)
```

- Еще один вариант описывания методов
```lua
local lamp = {
  on = false,
}
-- Неявное описание метода через функции

-- Ч/з точку
-- Аргумент необходимо указывать явно
function lamp.turn_on(l)
  l.on = true
  print("ON")
end

-- Ч/з двоеточие
-- Аргумент неявно задается сам как переменная "self"
function lamp:turn_off()
  self.on = false
  print("OFF")
end

lamp:turn_on()
lamp:turn_off()
```


### Специальные функции
---
Некоторые имена функций таблиц (методов) зарезервированы, и они несут особый смысл

```lua
-- Арифметические операции
__add(a,b)
__sub(a,b)
__div(a,b)
__mul(a,b)
__mod(a,b)
__pow(a,b)

__unm(a) -- унарная операция "минус" (на-р: x = -y)

-- Операции сравнения
__lt(a,b)
__le(a,b)
__eq(a,b)

__len(a) -- Для #a

__concat(a, b) -- Для a..b

__call(a, ...) -- Для a(), Переменные аргументы, это аргументы при вызове

index(a, i) -- Обращение к a[i], при условии, что такого эл-та не существует

__newindex(a, i, v) -- Создание a[i] = v

(!!!) __gc(a) -- когда объект удаляется при сборке муссора
```

### Наследование
---
- В Lua есть поняте мета-таблица (таблица-предок)
- У каждой таблицы есть одна таблица предок
- Дочерняя таблица умеет делать все, что умеет предок

```lua
local superlamp = {
  brightness = 100
}

-- Указываем родительскую таблицу для дочерней
superlamp = setmetatable(lamp, superlamp)

superlamp:turn_on() -- ON
superlamp:turn_off() -- OFF
```

### Расширение функциональности
---
Родительские таблицы есть у многих типов, на-р:
- строки
- таблицы

Родительских таблиц нет у
- чисел
- булевых чисел
- nil

Подмена метода у родительского класса всех строк
```lua
-- Получаем родительскую таблицу строки
local s = getmetatable("")
-- Подменяем метод
s.__add = function(s1, s2) return s1..s2 end

local a = 'hello'
local b = 'world'

print(a + b)
```
*Также можно подменить действие функции `print`*
`print = my_func`


## Области видимости
---
По умолчанию все переменные Глобальные
(ПОЧЕМУ)
Для указания local переменной пишется `local`
```lua
local var1, var2 = 5, 3
```


## Обработка ошибок
---
В lua используется что-то вроде исключений (exceptions)

Ошибки пораждаются с помощью функции `error(x)`
*В качестве аргумента можно передать все, что угодно (то, что имеет отношение к ошибке - строковое описание, числовой код, объект, с которым произошла ошибка и тд)*

После этой функции вся программа аварийно завершается.

Если вызывать функцию, которая может создать ошибку (или ее дочерние функции могут создать ошибку), то ее стоит вызывать безопасно при помощи pcall()

```lua
local function f(x, y)
 if true then
  error("failed to do somthing")
  else
    print(x + y)
 end
end

local x = 1
local y = 1

-- pcall(сама функция, ее, аргументы)
-- Лучше вместо err написать _
local status, err = pcall(f, x, y)

if not status then
  print("Ошибка обработана")
  -- Обработать ошибку err
end
```
